· Check that all states are reachable under some combination of events. · Check that no state is a dead end from which no combination of events will transition the object out of that state. · Trace through the state machine, either manually or by using tools, to check it against expected sequences of events and their responses. For example, Figure 24-2 shows the statechart diagram for parsing a simple context-free language, such as you might find in systems that stream in or stream out messages to XML. In this case, the machine is designed to parse a stream of characters that match the syntax Figure 24-2 Modeling Reactive Objects                  message : '<'string '>'string ';' The first string represents a tag; the second string represents the body of the message. Given a stream of characters, only well-formed messages that follow this syntax may be accepted. Events are discussed in Chapter 20. As the figure shows, there are only three stable states for this state machine: Waiting, GettingToken, and GettingBody. This statechart is designed as a Mealy machine, with actions tied to transitions. In fact, there is only one event of interest in this state machine, the invocation of put with the actual parameter c (a character). While Waiting, this machine throws away any character that does not designate the start of a token (as specified by the guard condition). When the start of a token is received, the state of the object changes to GettingToken. While in that state, the machine saves any character that does not designate the end of a token (as specified by the guard condition). When the end of a token is received, the state of the object changes to GettingBody. While in that state, the machine saves any character that does not designate the end of a message body (as specified by the guard condition). When the end of a message is received, the state of the object changes to Waiting, 