· In general, populate your models that are at a high level of abstraction with simple abstractions and your models that are at a low level of abstraction with detailed abstractions. Establish trace dependencies among the related elements of different models. · In practice, if you follow the five views of an architecture, there are four common situations you'll encounter when modeling a system at different levels of abstraction: 1. Use cases and their realization:   Use cases in a use case model will trace to collaborations in a design model. 2. Collaborations and their realization:   Collaborations will trace to a society of classes that work together to carry out the collaboration. 3. Components and their design:   Components in an implementation model will trace to the elements in a design model. 4. Nodes and their components:   Nodes in a deployment model will trace to components in an implementation model. Use cases are discussed in Chapter 16; collaborations are discussed in Chapter 27; components are discussed in Chapter 25; nodes are discussed in Chapter 26. The main advantage of the approach is that diagrams at different levels of abstraction remain more loosely coupled. This means that changes in one model will have less direct effect on other models. The main disadvantage of this approach is that you must spend resources to keep these models and their diagrams synchronized. This is especially true when your models parallel different phases of the software development life cycle, such as when you decide to maintain an analysis model separate from a design model. Interaction diagrams are discussed in Chapter 18. For example, suppose you are modeling a system for Web commerce#one of the main use cases of such a system would be for placing an order. If you're an analyst or an end user, you'd probably create some interaction diagrams at a high level of abstraction that show the action of placing an order, as in Figure 7-1. Figure 7-1 Interaction Diagram at a High Level of Abstraction 