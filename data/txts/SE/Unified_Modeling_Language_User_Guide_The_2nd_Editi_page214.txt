Timing marks are discussed in Chapter 23; pre- and post conditions are discussed in Chapter 4; packages are discussed in Chapter 12. As with sequence diagrams, a single collaboration diagram can show only one flow of control (although you can show simple variations by using the UML's notation for interaction and branching). Typically, you'll have a number of such interaction diagrams, some of which are primary and others that show alternative paths or exceptional conditions. You can use packages to organize these collections of collaboration diagrams, giving each diagram a suitable name to distinguish it from its siblings. For example, Figure 18-5 shows a collaboration diagram that specifies the flow of control involved in registering a new student at a school, with an emphasis on the structural relationships among these objects. You see five objects: a RegistrarAgent (r), a Student (s), two Course objects (c1 and c2), and an unnamed School object. The flow of control is numbered explicitly. Action begins with the RegistrarAgent creating a Student object, adding the student to the school (the message addStudent), then telling the Student object to register itself. The Student object then invokes getSchedule on itself, presumably obtaining the Course objects for which it must register. The Student object then adds itself to each Course object. The flow ends with s rendered again, showing that it has an updated value for its registered attribute. Figure 18-5 Modeling Flows of Control by Organization  Note that this diagram shows a link between the School object and the two Course objects, plus another link between the School object and the Student object, although no messages are shown along these paths. These links help explain how the Student object can see the two Course objects to which it adds itself. s, c1, and c2 are linked to the School via association, so s can find c1 and c2 during its call to getSchedule (which might return a collection of Course objects), indirectly through the School object. Forward and Reverse Engineering Forward engineering (the creation of code from a model) is possible for both sequence and collaboration diagrams, especially if the context of the diagram is an operation. For example, using the previous collaboration diagram, a reasonably clever forward engineering tool could generate the following Java code for the operation register, attached to the Student class. 