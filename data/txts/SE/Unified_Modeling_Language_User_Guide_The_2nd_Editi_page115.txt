The UML distinguishes between operation and method. An operation specifies a service that can be requested from any object of the class to affect behavior; a method is an implementation of an operation. Every nonabstract operation of a class must have a method, which supplies an executable algorithm as a body (generally designated in some programming language or structured text). In an inheritance lattice, there may be many methods for the same operation, and polymorphism selects which method in the hierarchy is dispatched during run time.  You can also use stereotypes to designate sets of related operations, such as helper functions, as discussed in Chapter 6. In its full form, the syntax of an operation in the UML is                   [visibility] name [(parameter-list)]              [: return-type] [{property-string}] For example, the following are all legal operation declarations: $ display  Name only $ + display  Visibility and name $ set(n : Name, s : String)  Name and parameters $ getID() : Integer  Name and return type $ restart() {guarded}  Name and property In an operation's signature, you may provide zero or more parameters, each of which follows the syntax                   [direction] name : type [= default-value] Direction may be any of the following values: $ in  An input parameter; may not be modified $ out  An output parameter; may be modified to communicate information to the caller $ inout  An input parameter; may be modified In addition to the leaf property described earlier, there are four defined properties that you can use with operations. 1. isQuery  Execution of the operation leaves the state of the system unchanged. In other words, the operation is a pure function that has no side effects. 2. sequential  Callers must coordinate outside the object so that only one flow is in the object at a time. In the presence of multiple flows of control, the semantics and integrity of the object cannot be guaranteed. 3. guarded  The semantics and integrity of the object is guaranteed in the presence of multiple flows of control by sequentializing all calls to all of the object's guarded operations. In effect, exactly one operation at a time can be invoked on the object, reducing this to sequential semantics. 4. concurrent  The semantics and integrity of the object is guaranteed in the presence of multiple flows of control by treating the operation as atomic. Multiple calls from concurrent flows of control may occur simultaneously to one object on any concurrent operation, and all may proceed concurrently with correct semantics; 