If you develop software in Java, you'll usually save your source code in .java files. If you develop software using C++, you'll typically store your source code in header files (.h files) and bodies (.cpp files). If you use IDL to develop COM+ or CORBA applications, one interface from your design view will often expand into four source code files: the interface itself, the client proxy, the server stub, and a bridge class. As your application grows, no matter which language you use, you'll find yourself organizing these files into larger groups. Furthermore, during the construction phase of development, you'll probably end up creating new versions of some of these files for each new incremental release you produce, and you'll want to place these versions under the control of a configuration management system. The file stereotype for components is discussed in Chapter 25. Much of the time, you will not need to model this aspect of a system directly. Instead, you'll let your development environment keep track of these files and their relationships. Sometimes, however, it's helpful to visualize these source code files and their relationships using component diagrams. Component diagrams used in this way typically contain only work-product components stereotyped as files, together with dependency relationships. For example, you might reverse engineer a set of source code files to visualize their web of compilation dependencies. You can go in the other direction by specifying the relationships among your source code files and then using those models as input to compilation tools, such as make on Unix. Similarly, you might want to use component diagrams to visualize the history of a set of source code files that are under configuration management. By extracting information from your configuration management system, such as the number of times a source code file has been checked out over a period of time, you can use that information to color component diagrams, showing "hot spots" of change among your source code files and areas of architectural churn. To model a system's source code, 路 Either by forward or reverse engineering, identify the set of source code files of interest and model them as components stereotyped as files. 路 For larger systems, use packages to show groups of source code files. 路 Consider exposing a tagged value indicating such information as the version number of the source code file, its author, and the date it was last changed. Use tools to manage the value of this tag. 路 Model the compilation dependencies among these files using dependencies. Again, use tools to help generate and manage these dependencies. The trace dependency stereotype is discussed in Chapter 10. For example, Figure 29-2 shows five source code files. signal.h is a header file. Three of its versions are shown, tracing from new versions back to their older ancestors. Each variant of this source code file is rendered with a tagged value exposing its version number. Figure 29-2 Modeling Source Code 