Process views in the context of software architecture are discussed in Chapter 2. Active objects play an important role in visualizing, specifying, constructing, and documenting a system's process view. The process view of a system encompasses the threads and processes that form the system's concurrency and synchronization mechanisms. This view primarily addresses the performance, scalability, and throughput of the system. With the UML, the static and dynamic aspects of this view are captured in the same kinds of diagrams as for the design view#that is, class diagrams, interaction diagrams, activity diagrams, and statechart diagrams, but with a focus on the active classes that represent these threads and processes. Common Modeling Techniques Modeling Multiple Flows of Control Mechanisms are discussed in Chapter 28 ; class diagrams are discussed in Chapter 8 ; interaction diagrams are discussed in Chapter 18. Building a system that encompasses multiple flows of control is hard. Not only do you have to decide how best to divide work across concurrent active objects, but once you've done that, you also have to devise the right mechanisms for communication and synchronization among your system's active and passive objects to ensure that they behave properly in the presence of these multiple flows. For that reason, it helps to visualize the way these flows interact with one another. You can do that in the UML by applying class diagrams (to capture their static semantics) and interaction diagrams (to capture their dynamic semantics) containing active classes and objects. To model multiple flows of control, Process views are discussed in Chapter 2 ; classes are discussed in Chapters 4 and 9 ; relationships are discussed in Chapters 5 and10. · Identify the opportunities for concurrent action and reify each flow as an active class. Generalize common sets of active objects into an active class. Be careful not to over-engineer the process view of your system by introducing too much concurrency. · Consider a balanced distribution of responsibilities among these active classes, then examine the other active and passive classes with which each collaborates statically. Ensure that each active class is both tightly cohesive and loosely coupled relative to these neighboring classes and that each has the right set of attributes, operations, and signals. · Capture these static decisions in class diagrams, explicitly highlighting each active class. · Consider how each group of classes collaborates with one another dynamically. Capture those decisions in interaction diagrams. Explicitly show active objects as the root of such flows. Identify each related sequence by identifying it with the name of the active object. · Pay close attention to communication among active objects. Apply synchronous and asynchronous messaging, as appropriate. · Pay close attention to synchronization among these active objects and the passive objects with which they collaborate. Apply sequential, guarded, or concurrent operation semantics, as appropriate. For example, Figure 22-4 shows part of the process view of a trading system. You'll find three objects that push information into the system concurrently: a StockTicker, an IndexWatcher, and a CNNNewsFeed (named s, i, and c, respectively). Two of these objects 