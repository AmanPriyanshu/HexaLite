 If an operation involves the interaction of a society of objects, you can also model the realization of that operation using collaborations, as discussed in Chapter 27. The algorithm of this operation is simple, as shown in the following activity diagram. First, there's a guard that tests whether the slope of the current line is the same as the slope of parameter l. If so, the lines do not intersect, and a Point at (0,0) is returned. Otherwise, the operation first calculates an x value for the point of intersection, then a y value; x and y are both objects local to the operation. Finally, a Point at (x,y) is returned. Note Using activity diagrams to flowchart an operation lies on the edge of making the UML a visual programming language. You can<canII> flowchart every operation, but pragmatically, you won't want to. Writing the body of an operation in a specific programming language is usually more direct. You will want to use activity diagrams to model an operation when the behavior of that operation is complex and therefore difficult to understand just by staring at code. Looking at a flowchart will reveal things about the algorithm you could not have seen just by looking at the code.  Forward and Reverse Engineering Forward engineering (the creation of code from a model) is possible for activity diagrams, especially if the context of the diagram is an operation. For example, using the previous activity diagram, a forward engineering tool could generate the following C++ code for the operation intersection.                Point Line::intersection (l : Line) {           if (slope == l.slope) return Point(0,0);           int x = (l.delta - delta) / (slope - l.slope);           int y = (slope * x) + delta; 