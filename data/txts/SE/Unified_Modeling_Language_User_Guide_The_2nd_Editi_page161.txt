textual string, such as t and myCustomer in Figure 13-2. That name alone is known as a simple name. The abstraction of the instance may be a simple name (such as Transaction) or it may be a path name (such as Multimedia::AudioStream) which is the abstraction's name prefixed by the name of the package in which that abstraction lives. When you explicitly name an object, you are really giving it a name (such as t) that's usable by a human. You can also simply name an object (such as aCustomer) and elide its abstraction if it's obvious in the given context. In many cases, however, the real name of an object is known only to the computer on which that object lives. In such cases, you can render an anonymous object (such as : Multimedia::AudioStream). Each occurrence of an anonymous object is considered distinct from all other occurrences. If you don't even know the object's associated abstraction, you must at least give it an explicit name (such as agent :). You can use stereotypes to denote the kind of collection represented by a multiobject. Stereotypes are discussed in Chapter 6. Especially when you are modeling large collections of objects, it's clumsy to render the collection itself plus its individual instances. Instead, you can model multiobjects (such as : keyCode) as in Figure 13-2, representing a collection of anonymous objects. Note An instance name may be text consisting of any number of letters, numbers, and certain punctuation marks (except for marks such as the colon, which is used to separate the name of the instance from the name of its abstraction) and may continue over several lines. In practice, instance names are short nouns or noun phrases drawn from the vocabulary of the system you are modeling. Typically, you capitalize the first letter of all but the first word in an instance name, as in t or myCustomer.  Operations Operations are discussed in Chapters 4 and 9; polymorphism is discussed in Chapter 9. Not only is an object something that usually takes up space in the real world, it is also something you can do things to. The operations you can perform on an object are declared in the object's abstraction. For example, if the class Transaction defines the operation commit, then given the instance t : Transaction, you can write expressions such as t.commit(). The execution of this expression means that t (the object) is operated on by commit (the operation). Depending on the inheritance lattice associated with Transaction, this operation may or may not be invoked polymorphically. State Attributes are discussed in Chapter 4; interaction diagrams are discussed in Chapter 18. Another way to show the changing state of an individual object over time is via state machines, which are discussed in Chapter 21. An object also has state, which in this sense encompasses all the (usually static) properties of the object plus the current (usually dynamic) values of each of these properties. These properties include the attributes of the object, as well as all its aggregate parts. An object's state is therefore dynamic. So when you visualize its state, you are really specifying the value of its state at a given moment in time and space. It's possible to show the changing state of an object by showing it 