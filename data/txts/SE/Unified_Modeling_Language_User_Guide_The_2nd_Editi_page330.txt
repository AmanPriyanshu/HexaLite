 This header file (signal.h) is used by two other files (interp.cpp and .signal.cpp), both of which are bodies. One of these files (interp.cpp) has a compilation dependency to another header (irq.h); in turn, device.cpp has a compilation dependency to interp.cpp. Given this component diagram, it's easy to trace the impact of changes. For example, changing the source code file signal.h will require the recompilation of three other files: signal.cpp, interp.cpp, and transitively, device.cpp. As this diagram also shows, the file irq.h is not affected. Diagrams such as this can easily be generated by reverse engineering from the information held by your development environment's configuration management tools. Modeling an Executable Release Releasing a simple application is easy: You throw the bits of a single executable file on a disk, and your users just run that executable. For these kinds of applications, you don't need component diagrams because there's nothing difficult to visualize, specify, construct, or document. Releasing anything other than a simple application is not so easy. You need the main executable (usually, a .exe file), but you also need all its ancillary parts, such as libraries (commonly .dll files if you are working in the context of COM+, or .class and .jar files if you are working in the context of Java), databases, help files, and resource files. For distributed systems, you'll likely have multiple executables and other parts scattered across various nodes. If you are working with a system of applications, you'll find that some of these components are unique to each application but that many are shared among applications. As you evolve your system, controlling the configuration of these many components becomes an important activity#and a more difficult one because changes in the components associated with one application may affect the operation of other applications. 