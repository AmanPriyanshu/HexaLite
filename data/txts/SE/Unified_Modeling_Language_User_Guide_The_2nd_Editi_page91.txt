路 Decide which views you need to best express the architecture of your system and to expose the technical risks to your project. The five views of an architecture described earlier are a good starting point. 路 For each of these views, decide which artifacts you need to create to capture the essential details of that view. For the most part, these artifacts will consist of various UML diagrams. 路 As part of your process planning, decide which of these diagrams you'll want to put under some sort of formal or semi-formal control. These are the diagrams for which you'll want to schedule reviews and to preserve as documentation for the project. 路 Allow room for diagrams that are thrown away. Such transitory diagrams are still useful for exploring the implications of your decisions and for experimenting with changes. For example, if you are modeling a simple monolithic application that runs on a single machine, you might need only the following handful of diagrams. $ Use case view  Use case diagrams $ Design view  Class diagrams (for structural modeling) Interaction diagrams (for behavioral modeling) $ Process view  None required $ Implementation view  None required $ Deployment view  None required If yours is a reactive system or if it focuses on process flow, you'll probably want to include statechart diagrams and activity diagrams, respectively, to model your system's behavior. Similarly, if yours is a client/server system, you'll probably want to include component diagrams and deployment diagrams to model the physical details of your system. Finally, if you are modeling a complex, distributed system, you'll need to employ the full range of the UML's diagrams in order to express the architecture of your system and the technical risks to your project, as in the following. $ Use case view Use case diagrams Activity diagrams (for behavioral modeling) $ Design view Class diagrams (for structural modeling) Interaction diagrams (for behavioral modeling) Statechart diagrams (for behavioral modeling) $ Process view Class diagrams (for structural modeling) Interaction diagrams (for behavioral modeling) $ Implementation view Component diagram $ Deployment view Deployment diagrams Modeling Different Levels of Abstraction Not only do you need to view a system from several angles, you'll also find people involved in development who need the same view of the system but at different levels of abstraction. For example, given a set of classes that capture the vocabulary of your problem space, a programmer might want a detailed view down to the level of each class's attributes, operations, and relationships. On the other hand, an analyst who's walking through some use case scenarios with an end user will likely want only a much elided view of these same classes. In this context, the programmer is working at a lower level of abstraction and the analysis and end user are working at a higher level of abstraction, but all are working from the same model. In fact, because diagrams are just a graphical presentation of the elements that make up a model, you can create 