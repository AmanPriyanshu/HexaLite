sorts of race conditions and interference that cause concurrent systems to fail in mysterious and unrepeatable ways. The key to solving this problem in object-oriented systems is by treating an object as a critical region. There are three alternatives to this approach, each of which involves attaching certain synchronization properties to the operations defined in a class. In the UML, you can model all three approaches. 1. Sequential  Callers must coordinate outside the object so that only one flow is in the object at a time. In the presence of multiple flows of control, the semantics and integrity of the object cannot be guaranteed. 2. Guarded  The semantics and integrity of the object is guaranteed in the presence of multiple flows of control by sequentializing all calls to all of the object's guarded operations. In effect, exactly one operation at a time can be invoked on the object, reducing this to sequential semantics. 3. Concurrent  The semantics and integrity of the object is guaranteed in the presence of multiple flows of control by treating the operation as atomic. Some programming languages support these constructs directly. Java, for example, has the synchronized property, which is equivalent to the UML's concurrent property. In every language that supports concurrency, you can build support for all these properties by constructing them out of semaphores. Constraints are discussed in Chapter 6. As Figure 22-3 shows, you can attach these properties to an operation, which you can render in the UML by using constraint notation. Figure 22-3 Synchronization  Note It is possible to model variations of these synchronization primitives by using constraints. For example, you might modify the concurrent property by allowing multiple simultaneous readers but only a single writer.  Process Views 