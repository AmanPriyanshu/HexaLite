Note This is what distinguishes sequential substates and concurrent substates. Given two or more sequential substates at the same level, an object will be in one of those substates or the other. Given two or more concurrent substates at the same level, an object will be in a sequential state from each one of the concurrent substates.  Execution of these two concurrent substates continues in parallel. Eventually, each nested state machine reaches its final state. If one concurrent substate reaches its final state before the other, control in that substate waits at its final state. When both nested state machines reach their final state, control from the two concurrent substates joins back into one flow. Whenever there's a transition to a composite state decomposed into concurrent substates, control forks into as many concurrent flows as there are concurrent substates. Similarly, whenever there's a transition from a composite substate decomposed into concurrent substates, control joins back into one flow. This holds true in all cases. If all concurrent substates reach their final state, or if there is an explicit transition out of the enclosing composite state, control joins back into one flow. Note A nested concurrent state machine does not have an initial, final, or history state. However, the sequential substates that compose a concurrent state may have these features. Common Modeling Techniques Modeling the Lifetime of an Object Objects are discussed in Chapter 13;classes are discussed in Chapters 4 and 9; use cases are discussed in Chapter 16;systems are discussed in Chapter 31;interactions are discussed in Chapter 15. The most common purpose for which you'll use state machines is to model the lifetime of an object, especially instances of classes, use cases, and the system as a whole. Whereas interactions model the behavior of a society of objects working together, a state machine models the behavior of a single object over its lifetime, such as you'll find with user interfaces, controllers, and devices. When you model the lifetime of an object, you essentially specify three things: the events to which the object can respond, the response to those events, and the impact of the past on current behavior. Modeling the lifetime of an object also involves deciding on the order in which the object can meaningfully respond to events, starting at the time of the object's creation and continuing until its destruction. To model the lifetime of an object, Collaborations are discussed in Chapter 27. Pre- and postconditions are discussed in Chapter 10; interfaces are discussed in Chapter 11. Â· Set the context for the state machine, whether it is a class, a use case, or the system as a whole. 