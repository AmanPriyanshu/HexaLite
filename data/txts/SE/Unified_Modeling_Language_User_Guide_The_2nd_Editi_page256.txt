1. If the context is a class or a use case, collect the neighboring classes, including any parents of the class and any classes reachable by associations or dependences. These neighbors are candidate targets for actions and are candidates for including in guard conditions. 2. f the context is the system as a whole, narrow your focus to one behavior of the system. Theoretically, every object in the system may be a participant in a model of the system's lifetime, and except for the most trivial systems, a complete model would be intractable. · Establish the initial and final states for the object. To guide the rest of your model, possibly state the pre- and postconditions of the initial and final states, respectively. · Decide on the events to which this object may respond. If already specified, you'll find these in the object's interfaces; if not already specified, you'll have to consider which objects may interact with the object in your context, and then which events they may possibly dispatch. · Starting from the initial state to the final state, lay out the top-level states the object may be in. Connect these states with transitions triggered by the appropriate events. Continue by adding actions to these transitions. · Identify any entry or exit actions (especially if you find that the idiom they cover is used in the state machine). · Expand these states as necessary by using substates. · Check that all events mentioned in the state machine match events expected by the interface of the object. Similarly, check that all events expected by the interface of the object are handled by the state machine. Finally, look to places where you explicitly want to ignore events. · Check that all actions mentioned in the state machine are sustained by the relationships, methods, and operations of the enclosing object. · Trace through the state machine, either manually or by using tools, to check it against expected sequences of events and their responses. Be especially diligent in looking for unreachable states and states in which the machine may get stuck. · After rearranging your state machine, check it against expected sequences again to ensure that you have not changed the object's semantics. For example, Figure 21-8 shows the state machine for the controller in a home security system, which is responsible for monitoring various sensors around the perimeter of the house. Figure 21-8 Modeling the Lifetime of An Object 