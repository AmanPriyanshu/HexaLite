As this diagram also shows, ledger.dll imports two interfaces, IStreaming and ITransaction, the latter of which is shown in its expanded form. These two interfaces are required by the ledger.dll component for its proper operation. Therefore, in a running system, you must supply components that realize these two interfaces. By identifying interfaces such as ITransaction, you've effectively decoupled the components on either side of the interface, permitting you to employ any component that conforms to that interface. Use cases are discussed in Chapter 16. Interfaces such as ITransaction are more than just a pile of operations. This particular interface makes some assumptions about the order in which its operations should be called. Although not shown here, you could attach use cases to this interface and enumerate the common ways you'd use it. Modeling Static and Dynamic Typeseling Static and Dynamic Types Instances are discussed in Chapter 13. Most object-oriented programming languages are statically typed, which means that the type of an object is bound at the time the object is created. Even so, that object will likely play different roles over time. This means that clients that use that object interact with the object through different sets of interfaces, representing interesting, possibly overlapping, sets of operations. Class diagrams are discussed in Chapter 8. Modeling the static nature of an object can be visualized in a class diagram. However, when you are modeling things like business objects, which naturally change their roles throughout a workflow, it's sometimes useful to explicitly model the dynamic nature of that object's type. In these circumstances, an object can gain and lose types during its life. Associations andgeneralizations are discussed in Chapters 5 and 10. IInteraction diagrams are discussed in Chapter 18. To model a dynamic type, 路 Specify the different possible types of that object by rendering each type as a class stereotyped as type (if the abstraction requires structure and behavior) or as interface (if the abstraction requires only behavior). 路 Model all the roles the class of the object may take on at any point in time. You can do so in two ways: 1. First, in a class diagram, explicitly type each role that the class plays in its association with other classes. Doing this specifies the face instances of that class put on in the context of the associated object. 2. Second, also in a class diagram, specify the class-to-type relationships using generalization. 路 In an interaction diagram, properly render each instance of the dynamically typed class. Display the role of the instance in brackets below the object's name. 路 To show the change in role of an object, render the object once for each role it plays in the interaction, and connect these objects with a message stereotyped as become. Dependencies are discussed in Chapters 5 and 10. 