You can control the visibility of the elements owned by a package just as you can control the visibility of the attributes and operations owned by a class. Typically, an element owned by a package is public, which means that it is visible to the contents of any package that imports the element's enclosing package. Conversely, protected elements can only be seen by children, and private elements cannot be seen outside the package in which they are declared. In Figure 12-3, OrderForm is a public part of the package Client, and Order is a private part. A package that imports Client can see OrderForm, but it cannot see Order. As viewed from the outside, the fully qualified name of OrderForm would be Client::OrderForm. You specify the visibility of an element owned by a package by prefixing the element's name with an appropriate visibility symbol. Public elements are rendered by prefixing their name with a + symbol, as for OrderForm in Figure 12-3. Collectively, the public parts of a package constitute the package's interface. Inheritance of packages is discussed in a later section. Just as with classes, you can designate an element as protected or private, rendered by prefixing the element's name with a # symbol and a - symbol, respectively. Protected elements are visible only to packages that inherit from another package; private elements are not visible outside the package at all. Friend dependency relationships are discussed in Chapter 10. Note Packages that are friends to another may see all the elements of that package, no matter what their visibility.  Importing and Exporting Suppose you have two classes named A and B sitting side by side. Because they are peers, A can see B and B can see A, so both can depend on the other. Just two classes makes for a trivial system, so you really don't need any kind of packaging. Now, imagine having a few hundred such classes sitting side by side. There's no limit to the tangled web of relationships that you can weave. Furthermore, there's no way that you can understand such a large, unorganized group of classes. That's a very real problem for large systems#simple, unrestrained access does not scale up. For these situations, you need some kind of controlled packaging to organize your abstractions. Dependency relationships are discussed in Chapter 5; the UML's extensibility mechanisms are discussed in Chapter 6. So suppose that instead you put A in one package and B in another package, both packages sitting side by side. Suppose also that A and B are both declared as public parts of their respective packages. This is a very different situation. Although A and B are both public, neither can access the other because their enclosing packages form an opaque wall. However, if A's package imports B's package, A can now see B, although B cannot see A. Importing grants a one-way permission for the elements in one package to access the elements in another package. In the UML, you model an import relationship as a dependency adorned with the stereotype import. By packaging your abstractions into meaningful chunks and then controlling their access by importing, you can control the complexity of large numbers of abstractions. 