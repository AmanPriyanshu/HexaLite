This figure shows one other dependency, this one not involving classes in operations but rather modeling a common C++ idiom. The dependency from Iterator shows that the Iterator uses the CourseSchedule; the CourseSchedule knows nothing about the Iterator. The dependency is marked with a stereotype, which specifies that this is not a plain dependency, but, rather, it represents a friend, as in C++. Modeling Single Inheritance In modeling the vocabulary of your system, you will often run across classes that are structurally or behaviorally similar to others. You could model each of these as distinct and unrelated abstractions. A better way would be to extract any common structural and behavioral features and place them in more-general classes from which the specialized ones inherit. To model inheritance relationships, · Given a set of classes, look for responsibilities, attributes, and operations that are common to two or more classes. · Elevate these common responsibilities, attributes, and operations to a more general class. If necessary, create a new class to which you can assign these elements (but be careful about introducing too many levels). · Specify that the more-specific classes inherit from the more-general class by placing a generalization relationship that is drawn from each specialized class to its more-general parent. For example, Figure 5-9 shows a set of classes drawn from a trading application. You will find a generalization relationship from four classes# CashAccount, Stock, Bond, and Property#to the more-general class named Security. Security is the parent, and CashAccount, Stock, Bond, and Property are all children. Each of these specialized children is a kind of Security. You'll notice that Security includes two operations: presentValue and history. Because Security is their parent, CashAccount, Stock, Bond, and Property all inherit these two operations, and for that matter, any other attributes and operations of Security that may be elided in this figure. Figure 5-9 Inheritance Relationships 