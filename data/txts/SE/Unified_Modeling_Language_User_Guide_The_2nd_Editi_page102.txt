 Modeling primitive types is discussed in Chapter 4; aggregation is discussed in Chapters 5 and 10. All six of these classes are marked as persistent, indicating that their instances are intended to live in a database or some other form of persistent store. This diagram also exposes the attributes of all six of these classes. Notice that all the attributes are primitive types. When you are modeling a schema, you'll generally want to model the relationship to any nonprimitive types using an explicit aggregation rather than an attribute. Two of these classes (School and Department) expose several operations for manipulating their parts. These operations are included because they are important to maintain data integrity (adding or removing a Department, for example, will have some rippling effects). There are many other operations that you might consider for these and the other classes, such as querying the prerequisites of a course before assigning a student. These are more business rules than they are operations for database integrity and so are best placed at a higher level of abstraction than this schema. Forward and Reverse Engineering The importance ofmodeling is discussed in Chapter 1. Modeling is important, but you have to remember that the primary product of a development team is software, not diagrams. Of course, the reason you create models is to predictably deliver at the right time the right software that satisfies the evolving goals of its users and the business. For this reason, it's important that the models you create and the implementations you deploy map to one another and do so in a way that minimizes or even eliminates the cost of keeping your models and your implementation in sync with one another. Activity diagrams are discussed in Chapter 19. 