 Internal Transitions   Once inside a state, you'll encounter events you'll want to handle without leaving the state. These are called internal transitions, and they are subtly different from self-transitions. In a self-transition, such as you see in Figure 21-3, an event triggers the transition, you leave the state, an action (if any) is dispatched, and then you reenter the same state. Because this transition exits and then enters the state, a self-transition dispatches the state's exit action, then it dispatches the action of the self-transition, and finally, it dispatches the state's entry action. However, suppose you want to handle the event but don't want to fire the state's entry and exit actions. Using flat state machines, you can achieve that effect, but you have to be diligent about remembering which of a state's transitions have these entry and exit actions and which do not. As Figure 21-4 shows, the UML provides a shorthand for this idiom, as well (for example, for the event newTarget). In the symbol for the state, you can include an internal transition (marked by an event). Whenever you are in the state and that event is triggered, the corresponding action is dispatched without leaving and then reentering the state. Therefore, the event is handled without dispatching the state's exit and then entry actions. Note Internal transitions may have events with parameters and guard conditions. As such, internal transitions are essentially interrupts.  Activities   When an object is in a state, it generally sits idle, waiting for an event to occur. Sometimes, however, you may wish to model an ongoing activity. While in a state, the object does some work that will continue until it is interrupted by an event. For example, if an object is in the Tracking state, it might followTarget as long as it is in that state. As Figure 21-4 shows, in the UML, you use the special do transition to specify the work that's to be done inside a state after the entry action is dispatched. The activity of a do transition might name another state machine (such as followTarget). You can also specify a sequence of actions#for example, do / op1(a); op2(b); op3(c). Actions are never interruptible, but sequences of actions are. In between each action (separated by the semicolon), events may be handled by the enclosing state, which results in transitioning out of the state. Events are discussed in Chapter 20. Deferred Events   Consider a state such as Tracking. As illustrated in Figure 21-3, suppose there's only one transition leading out of this state, triggered by the event contact. While in the state Tracking, any events other than contact and other than those handled by its substates will be lost. That means that the event may occur, but it will be postponed and no action will result because of the presence of that event. In every modeling situation, you'll want to recognize some events and ignore others. You include those you want to recognize as the event triggers of transitions; those you want to ignore you just leave out. However, in some modeling situations, you'll want to recognize some events but postpone a response to them until later. For example, while in the Tracking state, you may 