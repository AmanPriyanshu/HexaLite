Observe that executionTime may be applied to actions such as getImage, as well as to timing marks such as a and b. Also, timing constraints such as these may be written as free-form text. If you want to specify your semantics more precisely, you can use the UML's Object Constraint Language (OCL), described further in The Unified Modeling Language Reference Manual.  Often, you'll choose short names for messages, so that you don't confuse them with operation names. Modeling the Distribution of Objects Modeling the distribution of a component is discussed in Chapter 25. When you model the topology of a distributed system, you'll want to consider the physical placement of both components and class instances. If your focus is the configuration management of the deployed system, modeling the distribution of components is especially important in order to visualize, specify, construct, and document the placement of physical things such as executables, libraries, and tables. If your focus is the functionality, scalability, and throughput of the system, modeling the distribution of objects is what's important. Modeling processes and threads is discussed in Chapter 22. Deciding how to distribute the objects in a system is a wicked problem, and not just because the problems of distribution interact with the problems of concurrency. Naive solutions tend to yield profoundly poor performance, and over-engineering solutions aren't much better. In fact, they are probably worse because they usually end up being brittle. To model the distribution of objects, · For each interesting class of objects in your system, consider its locality of reference. In other words, consider all its neighbors and their locations. A tightly coupled locality will have neighboring objects close by; a loosely coupled one will have distant objects (and thus, there will be latency in communicating with them). Tentatively allocate objects closest to the actors that manipulate them. · Next consider patterns of interaction among related sets of objects. Co-locate sets of objects that have high degrees of interaction, to reduce the cost of communication. Partition sets of objects that have low degrees of interaction. · Next consider the distribution of responsibilities across the system. Redistribute your objects to balance the load of each node. · Consider also issues of security, volatility, and quality of service, and redistribute your objects as appropriate. · Render this allocation in one of two ways: 1. By nesting objects in the nodes of a deployment diagram 2. By explicitly indicating the location of the object as a tagged value Object diagrams are discussed in Chapter 14. 