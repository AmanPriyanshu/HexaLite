2. derive  Specifies that the source may be computed from the target Attributes are discussed in Chapters 4 and 9; associations are discussed in Chapter 5 and later in this chapter. You'll use derive when you want to model the relationship between two attributes or two associations, one of which is concrete and the other is conceptual. For example, a Person class might have the attribute BirthDate (which is concrete), as well as the attribute Age (which can be derived from BirthDate, so is not separately manifest in the class). You'd show the relationship between Age and BirthDate by using a derive dependency, showing Age derived from BirthDate. 3. friend  Specifies that the source is given special visibility into the target Friend dependencies are discussed in Chapter 5. You'll use friend when you want to model relationships such as found with C++ friend classes. 4. instanceOf  Specifies that the source object is an instance of the target classifier 5. instantiate  Specifies that the source creates instances of the target The class/object dichotomy is discussed in Chapter 2. These last two stereotypes let you model class/object relationships explicitly. You'll use instanceOf when you want to model the relationship between a class and an object in the same diagram, or between a class and its metaclass. You'll use instantiate when you want to specify which element creates objects of another. 6. powertype  Specifies that the target is a powertype of the source; a powertype is a classifier whose objects are all the children of a given parent Modeling logical databases is discussed in Chapter 8; modeling physical databases is discussed in Chapter 29. You'll use powertype when you want to model classes that cover other classes, such as you'll find when modeling databases. 7. refine  Specifies that the source is at a finer degree of abstraction than the target You'll use refine when you want to model classes that are essentially the same but at different levels of abstraction. For example, during analysis, you might encounter a Customer class which, during design, you refine into a more detailed Customer class, complete with its implementation. 8. use  Specifies that the semantics of the source element depends on the semantics of the public part of the target You'll apply use when you want to explicitly mark a dependency as a using relationship, in contrast to the shades of dependencies other stereotypes provide. Packages are discussed in Chapter 12. Continuing, there are two stereotypes that apply to dependency relationships among packages. 1. access  Specifies that the source package is granted the right to reference the elements of the target package 2. A kind of access that specifies that the public contents of the target package enter the 