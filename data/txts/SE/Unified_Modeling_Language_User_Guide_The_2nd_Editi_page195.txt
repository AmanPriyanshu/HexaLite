Systems and subsystems are discussed in Chapter 31; classes are discussed in Chapters 4 and 9. The most common thing for which you'll apply use cases is to model the behavior of an element, whether it is the system as a whole, a subsystem, or a class. When you model the behavior of these things, it's important that you focus on what that element does, not how it does it. Applying use cases to elements in this way is important for three reasons. First, by modeling the behavior of an element with use cases, you provide a way for domain experts to specify its outside view to a degree sufficient for developers to construct its inside view. Use cases provide a forum for your domain experts, end users, and developers to communicate to one another. Second, use cases provide a way for developers to approach an element and understand it. A system, subsystem, or class may be complex and full of operations and other parts. By specifying an element's use cases, you help users of these elements to approach them in a direct way, according to how they are likely to use them. In the absence of such use cases, users have to discover on their own how to use those elements. Use cases let the author of an element communicate his or her intent about how that element should be used. Third, use cases serve as the basis for testing each element as it evolves during development. By continuously testing each element against its use cases, you continuously validate its implementation. Not only do these use cases provide a source of regression tests, but every time you throw a new use case at an element, you are forced to reconsider your implementation to ensure that this element is resilient to change. If it is not, you must fix your architecture appropriately. To model the behavior of an element, · Identify the actors that interact with the element. Candidate actors include groups that require certain behavior to perform their tasks or that are needed directly or indirectly to perform the element's functions. · Organize actors by identifying general and more specialized roles. · For each actor, consider the primary ways in which that actor interacts with the element. Consider also interactions that change the state of the element or its environment or that involve a response to some event. · Consider also the exceptional ways in which each actor interacts with the element. · Organize these behaviors as use cases, applying include and extend relationships to factor common behavior and distinguish exceptional behavior. For example, a retail system will interact with customers who place and track orders. In turn, the system will ship orders and bill the customer. As Figure 16-6 shows, you can model the behavior of such a system by declaring these behaviors as use cases (Place order, Track order, Ship order, and Bill customer). Common behavior can be factored out (Validate customer) and variants (Ship partial order) can be distinguished, as well. For each of these use cases, you would include a specification of the behavior, either by text, state machine, or interactions. Figure 16-6 Modeling the Behavior of an Element 