However, you can model indirect instances of abstract classes in order to show the use of a prototypical instance of that abstract class. Literally, no such object might exist. But pragmatically, this instance lets you name one of any potential instances of concrete children of that abstract class. This same touch applies to interfaces. By their very definition, interfaces may not have any direct instances, but you can model a prototypical instance of an interface, representing one of any potential instances of concrete classes that realize that interface. Object diagrams are discussed in Chapter 14; interaction diagrams are discussed in Chapter 18; activity diagrams are discussed in Chapter 19; dynamic typing is discussed in Chapter 11; classifiers are discussed in Chapter 9. When you model instances, you'll place them in object diagrams (if you want to visualize their structural details) or in interaction and activity diagrams (if you want to visualize their participation in dynamic situations). Although typically not necessary, you can place objects in class diagrams if you want to explicitly show the relationship of an object to its abstraction. The classifier of an instance is usually static. For example, once you create an instance of a class, its class won't change during the lifetime of that object. In some modeling situations and in some programming languages, however, it is possible to change the abstraction of an instance. For example, a Caterpillar object might become a Butterfly object. It's the same object, but of a different abstraction. Note During development, it's also possible for you to have instances with no associated classifier, which you can render as an object but with its abstraction name missing, as in Figure 13-2. You can introduce orphan objects such as these when you need to model very abstract behavior, although you must eventually tie such instances to an abstraction if you want to enforce any degree of semantics about the object. Figure 13-2 Named, Anonymous, Multiple, and Orphan Instances   Names Operations are discussed in Chapters 4 and 9; components are discussed in Chapter 25; nodes are discussed in Chapter 26. Every instance must have a name that distinguishes it from other instances within its context. Typically, an object lives within the context of an operation, a component, or a node. A name is a 