 Note The distinction between flat and procedural sequences is subtle and is really an advanced modeling issue. Typically, you'll use flat sequences only when modeling interactions in the context of use cases that involve the system as a whole, together with actors outside the system. Such sequences are often flat because control simply progresses from step to step, without any consideration for nested flows of control. In just about all other circumstances, you'll want to use procedural sequences, because they represent ordinary, nested operation calls of the type you find in most programming languages.  Processes and threads are discussed in Chapter 22; you can also specify asynchronous flow of control, rendered using a half stick arrowhead, as discussed in Chapter 22. When you are modeling interactions that involve multiple flows of control, it's especially important to identify the process or thread that sent a particular message. In the UML, you can distinguish one flow of control from another by prefixing a message's sequence number with the name of the process or thread that sits at the root of the sequence. For example, the expression                D5 : ejectHatch(3) specifies that the operation ejectHatch is dispatched (with the actual argument 3) as the fifth message in the sequence rooted by the process or thread named D. Not only can you show the actual arguments sent along with an operation or a signal in the context of an interaction, you can show the return values of a function as well. As the following expression shows, the value p is returned from the operation find, dispatched with the actual parameter "Rachelle". This is a nested sequence, dispatched as the second message nested in the third message nested in the first message of the sequence. In the same diagram, p can then be used as an actual parameter in other messages. Iteration,branching, andguardedmessages are discussed in Chapter 18; timing marks are discussed in Chapter 23; stereotypes andconstraints are discussed in Chapter 6.                1.3.2 : p := find("Rachelle") Note In the UML, you can also model more-complex forms of sequencing, such as iteration, branching, and guarded messages. In addition, to model timing constraints such as you might find in real time systems, you can associate timing marks with a sequence. 