interrupting events means you end up with a multitude of transitions zeroing in on the same target state from various sources, but with the same event trigger, guard condition, and action. Using sequential substates, there's a simpler way to model this problem, as Figure 21-5 shows. Here, the Active state has a substructure, containing the substates Validating, Selecting, Processing, and Printing. The state of the ATM changes from Idle to Active when the customer enters a credit card in the machine. On entering the Active state, the entry action readCard is performed. Starting with the initial state of the substructure, control passes to the Validating state, then to the Selecting state, and then to the Processing state. After Processing, control may return to Selecting (if the customer has selected another transaction) or it may move on to Printing. After Printing, there's a triggerless transition back to the Idle state. Notice that the Active state has an exit action, which ejects the customer's credit card. Figure 21-5 Sequential Substates  Notice also the transition from the Active state to the Idle state, triggered by the event cancel. In any substate of Active, the customer might cancel the transaction, and that returns the ATM to the Idle state (but only after ejecting the customer's credit card, which is the exit action dispatched on leaving the Active state, no matter what caused a transition out of that state). Without substates, you'd need a transition triggered by cancel on every substructure state. Substates such as Validating and Processing are called sequential, or disjoint, substates. Given a set of disjoint substates in the context of an enclosing composite state, the object is said to be in the composite state and in only one of those substates (or the final state) at a time. Therefore, sequential substates partition the state space of the composite state into disjoint states. 