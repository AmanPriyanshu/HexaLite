interface IMember (and realized by some suitable class, also in the Student class hierarchy).  Sequencing Processes and threads are discussed in Chapter 22. When an object passes a message to another object (in effect, delegating some action to the receiver), the receiving object might in turn send a message to another object, which might send a message to yet a different object, and so on. This stream of messages forms a sequence. Any sequence must have a beginning; the start of every sequence is rooted in some process or thread. Furthermore, any sequence will continue as long as the process or thread that owns it lives. A nonstop system, such as you might find in real time device control, will continue to execute as long as the node it runs on is up. Systems are discussed in Chapter 31. Each process and thread within a system defines a distinct flow of control, and within each flow, messages are ordered in sequence by time. To better visualize the sequence of a message, you can explicitly model the order of the message relative to the start of the sequence by prefixing the message with a sequence number set apart by a colon separator. Most commonly, you can specify a procedural or nested flow of control, rendered using a filled solid arrowhead, as Figure 15-4 shows. In this case, the message findAtis specified as the first message nested in the second message of the sequence (2.1). Figure 15-4 Procedural Sequence  Less common but also possible, as Figure 15-5 shows, you can specify a flat flow of control, rendered using a stick arrowhead, to model the nonprocedural progression of control from step to step. In this case, the message assertCall is specified as the second message in the sequence. Figure 15-5 Flat Sequence 