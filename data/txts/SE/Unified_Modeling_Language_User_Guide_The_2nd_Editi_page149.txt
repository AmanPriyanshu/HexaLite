Elements of different kinds may have the same name within a package. Thus, you can have a class named Timer, as well as a component named Timer, within the same package. In practice, however, to avoid confusion, it's best to name elements uniquely for all kinds within a package. Importing is discussed in a later section. Packages may own other packages. This means that it's possible to decompose your models hierarchically. For example, you might have a class named Camera that lives in the package Vision that in turn lives in the package Sensors. The full name of this class is Sensors::Vision::Camera. In practice, it's best to avoid deeply nested packages. Two to three levels of nesting is about the limit that's manageable. More than nesting, you'll use importing to organize your packages. These semantics of ownership make packages an important mechanism for dealing with scale. Without packages, you'd end up with large, flat models in which all elements would have to be named uniquely#an unmanageable situation, especially when you've brought in classes and other elements developed by multiple teams. Packages help you control the elements that compose your system as they evolve at different rates over time. As Figure 12-3 shows, you can explicitly show the contents of a package either textually or graphically. Note that when you show these owned elements, you place the name of the package in the tab. In practice, you typically won't want to show the contents of packages this way. Instead, you'll use tools to zoom into the contents of a package. Figure 12-3 Owned Elements  Note The UML assumes that there is an anonymous, root package in a model, the consequence of which is that elements of each kind at the top of a model must be uniquely named.  Visibility Visibility is discussed in Chapter 9. 