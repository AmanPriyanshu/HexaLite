Class diagrams are discussed in Chapter 8; the become stereotype is discussed in Chapter 13. A class diagram like this one is useful for modeling the static binding of an abstraction to its interface. You can model the dynamic binding of an abstraction to its interface by using the become stereotype in an interaction diagram, showing an object changing from one role to another. If you want to formally model the semantics of an abstraction and its conformance to a specific interface, you'll want to use the defined stereotype type. Type is a stereotype of class, and you use it to specify a domain of objects, together with the operations (but not the methods) applicable to the objects of that type. The concept of type is closely related to that of interface, except that a type's definition may include attributes while an interface may not. If you want to show that an abstraction is statically typed, you'll want to use implementationClass,a stereotype of class that specifies a class whose instances are statically typed (unlike Person in the example above) and that defines the physical data structure and methods of an object as implemented in traditional programming languages. Note For most uses, you may assume that type and interface are interchangeable. Common Modeling Techniques Modeling the Seams in a Systemeling the Seams in a System Components are discussed in Chapter 25; systems are discussed in Chapter 31. The most common purpose for which you'll use interfaces is to model the seams in a system composed of software components, such as COM+ or Java Beans. You'll reuse some components from other systems or buy off the shelf; you will create others from scratch. In any case, you'll need to write glue code that weaves these components together. That requires you to understand the interfaces provided and relied on by each component. Identifying the seams in a system involves identifying clear lines of demarcation in your architecture. On either side of those lines, you'll find components that may change independently, without affecting the components on the other side, as long as the components on both sides conform to the contract specified by that interface. Patterns andframeworks are discussed in Chapter 28. When you reuse a component from another system or when you buy it off the shelf, you'll probably be handed a set of operations with some minimal documentation about the meaning of each one. That's useful, but it's not sufficient. It's more important for you to understand the order in which to call each operation, and what underlying mechanisms the interface embodies. Unfortunately, given a poorly documented component, the best you can do is to build up, by trial and error, a conceptual model for how that interface works. You can then document your understanding by modeling that seam in the system using interfaces in the UML so that, later, you and others can approach that component more easily. Similarly, when you create your own component, you'll need to understand its context, which means specifying the interfaces it relies on to do its job, as well as the interfaces it presents to the world that others might build on. Note Most component systems, such as COM+ and Enterprise Java Beans, provide for component introspection, meaning that you can programmatically query an interface to 