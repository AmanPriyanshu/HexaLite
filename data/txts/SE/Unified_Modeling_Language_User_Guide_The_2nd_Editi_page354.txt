· Transitioning to the UML · Where to go next Simple problems are easy to model with the UML. Hard problems are easy to model, too, especially after you've become fluent in the language. Reading about using the UML is one thing, but it's only through using the language that you will come to master it. Depending on your background, there are different ways to approach using the UML for the first time. As you gain more experience, you will come to understand and appreciate its more subtle parts. If you can think it, the UML can model it. Transitioning to the UML You can model 80 percent of most problems by using about 20 percent of the UML. Basic structural things, such as classes, attributes, operations, use cases, components, and packages, together with basic structural relationships, such as dependency, generalization, and association, are sufficient to create static models for many kinds of problem domains. Add to that list basic behavioral things, such as simple state machines and interactions, and you can model many useful aspects of a system's dynamics. You'll need to use only the more advanced features of the UML once you start modeling the things you encounter in more-complex situations, such as modeling concurrency and distribution. A conceptual model for the UML is discussed in Chapter 2. A good starting place for using the UML is to model some of the basic abstractions or behavior that already exist in one of your systems. Develop a conceptual model of the UML so that you'll have a framework around which you can grow your understanding of the language. Later on, you'll better understand how the more advanced parts of the UML fit together. As you attack more-complex problems, drill down into specific features of the UML by studying the common modeling techniques in this book. If you are new to object-orientation, · Start by getting comfortable with the idea of abstraction. Team exercises with CRC cards and use case analysis are excellent ways to develop your skills of identifying crisp abstractions. · Model a simple static part of your problem using classes, dependency, generalization, and association to get familiar with visualizing societies of abstractions. · Use simple sequence or collaboration diagrams to model a dynamic part of your problem. Building a model of user interaction with the system is a good starting place and will give you an immediate payback by helping you reason through some of the system's more important use cases. If you are new to modeling, · Start by taking a part of some system you've already built#preferably implemented in some object-oriented programming language, such as Java or C++#and build a UML model of these classes and their relationships. · Using the UML, try to capture some details of programming idioms or mechanisms you used in that system, which are in your head but you can't put down directly in the code. 