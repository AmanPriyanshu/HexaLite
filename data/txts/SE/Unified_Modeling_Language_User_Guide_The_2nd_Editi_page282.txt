and a value is returned indicating that the message has been parsed (and the machine is ready to receive another message). Note that this statechart specifies a machine that runs continuously; there is no final state. Forward and Reverse Engineering Forward engineering(the creation of code from a model) is possible for statechart diagrams, especially if the context of the diagram is a class. For example, using the previous statechart diagram, a forward engineering tool could generate the following Java code for the class MessageParser.               class MessageParser {        public          boolean put(char c) {          switch (state) {           case Waiting:            if (c == '<') {             state = GettingToken;             token = new StringBuffer();             body = new StringBuffer();            }            break;          case GettingToken :           if (c == '>')            state = GettingBody;           else            token.append(c);          break;         case GettingBody :          if (c == ';')           state = Waiting;          else              body.append(c);          return true;       }      return false;     }     StringBuffer getToken() {       return token;     }     StringBuffer getBody() {       return body;     }   private      final static int Waiting = 0;     final static int GettingToken = 1;     final static int GettingBody = 2;     int state = Waiting;     StringBuffer token, body;   } This requires a little cleverness. The forward engineering tool must generate the necessary private attributes and final static constants. Reverse engineering (the creation of a model from code) is theoretically possible, but practically not very useful. The choice of what constitutes a meaningful state is in the eye of the designer. 