groups of these files when you fork and join development paths. In this manner, UML components can be the graphical interface to your configuration management and version control tools. For most systems, source code files are drawn from the decisions you make about how to segment the files your development environment needs. These files are used to store the details of your classes, interfaces, collaborations, and other logical elements as an intermediate step to creating the physical, binary components that are derived from these elements by your tools. Most of the time, these tools will impose a style of organization (one or two files per class is common), but you'll still want to visualize the relationships among these files. How you organize groups of these files using packages and how you manage versions of these files is driven by your decisions about how to manage change. To model source code, · Depending on the constraints imposed by your development tools, model the files used to store the details of all your logical elements, along with their compilation dependencies. · If it's important for you to bolt these models to your configuration management and version control tools, you'll want to include tagged values, such as version, author, and check in/check out information, for each file that's under configuration management. · As far as possible, let your development tools manage the relationships among these files, and use the UML only to visualize and document these relationships. For example, Figure 25-8 shows some source code files that are used to build the library render.dll from the previous examples. This figure includes four header files (render.h, rengine.h, poly.h, and colortab.h) that represent the source code for the specification of certain classes. There is also one implementation file (render.cpp) that represents the implementation of one of these headers. Figure 25-8 Modeling Source Code 