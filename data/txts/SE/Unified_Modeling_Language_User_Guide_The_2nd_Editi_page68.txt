 Abstract classes and operations are discussed in Chapter 9. You may notice that the names Security and presentValue are written a bit differently than others. There's a reason for this. When you build hierarchies as in the preceding figure, you often encounter nonleaf classes that are incomplete or are simply ones for which you don't want there to be any objects. Such classes are called abstract. You can specify a class as abstract in the UML by writing its name in italics, such as for the class Security. This convention applies to operations such presentValue and means that the given operation provides a signature but is otherwise incomplete and so must be implemented by some method at a lower level of abstraction. In fact, as the figure shows, all four of the immediate children of Security are concrete (meaning that they are nonabstract) and also provide a concrete implementation of the operation presentValue. Your generalization/specialization hierarchies don't have to be limited to only two levels. In fact, as the figure shows, it is common to have more than two layers of inheritance. SmallCapStock and LargeCapStock are both children of Stock, which, in turn, is a child of Security. Security is therefore a base class because it has no parents. SmallCapStock and LargeCapStock are both leaf classes because they have no children. Stock has a parent as well as children, and so it is neither a root nor a leaf class. Multiple inheritance is discussed in Chapter 10. Although it is not shown here, you can also create classes that have more than one parent. This is called multiple inheritance and means that the given class has all the attributes, operations, and associations of all its parents. Of course, there can be no cycles in an inheritance lattice; a given class cannot be its own parent. Modeling Structural Relationships When you model with dependencies or generalization relationships, you are modeling classes that represent different levels of importance or different levels of abstraction. Given a dependency 