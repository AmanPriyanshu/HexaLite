Sequential substates are the most common kind of nested state machine you'll encounter. In certain modeling situations, however, you'll want to specify concurrent substates. These substates let you specify two or more state machines that execute in parallel in the context of the enclosing object. Note Another way to model concurrency is by using active objects. Thus, rather than partitioning one object's state machine into two (or more) concurrent substates, you could define two active objects, each of which is responsible for the behavior of one of the concurrent substates. If the behavior of one of these concurrent flows is affected by the state of the other, you'll want to model this using concurrent substates. If the behavior of one of these concurrent flows is affected by messages sent to and from the other, you'll want to model this using active objects. If there's little or no communication between the concurrent flows, then the approach you choose is a matter of taste, although most of the time, using active objects makes your design decisions more obvious.  Forking andjoining are discussed in Chapter 19. For example, Figure 21-7 shows an expansion of the Maintenance state from Figure 21-5. Maintenance is decomposed into two concurrent substates, Testing and Commanding, shown by nesting them in the Maintenance state but separating them from one another with a dashed line. Each of these concurrent substates is further decomposed into sequential substates. When control passes from the Idle to the Maintenance state, control then forks to two concurrent flows#the enclosing object will be in the Testing state and the Commanding state. Furthermore, while in the Commanding state, the enclosing object will be in the Waiting or the Command state. Figure 21-7 Concurrent Substates  