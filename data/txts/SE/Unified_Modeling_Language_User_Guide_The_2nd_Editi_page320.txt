 Note Deciding to model a mechanism as a plain collaboration versus a parameterized one is straightforward. Use a plain collaboration if all you are doing is naming a specific society of classes in your system that work together; use a template collaboration if you can abstract the essential structural and behavioral aspects of the mechanism in a completely domain-independent way, which you can then bind to your abstractions in a given context.  Frameworks A framework is an architectural pattern that provides an extensible template for applications within a domain. For example, one common architectural pattern you'll encounter in real time systems is a cyclic executive, which divides time into frames and subframes, during which processing takes place under strict deadlines. Choosing this pattern versus its alternative (an even-driven architecture) colors your entire system. Because this pattern (and its alternative) is so common, it makes sense to name it as a framework. The five views of an architecture are discussed in Chapter 2. A framework is bigger than a mechanism. In fact, you can think of a framework as a kind of micro-architecture that encompasses a set of mechanisms that work together to solve a common problem for a common domain. When you specify a framework, you specify the skeleton of an architecture, together with the slots, tabs, knobs, and dials that you expose to users who want to adapt that framework to their own context. Packages are discussed in Chapter 12; stereotypes are discussed in Chapter 6. In the UML, you model a framework as a stereotyped package. Zoom inside that package, and you'll see mechanisms that live in any of various views of a system's architecture. For example, not only might you find parameterized collaborations, you might also find use cases (which explain how to use the framework), as well as plain collaborations (which provide sets of abstractions that you can build upon#for instance, by subclassing). Events are discussed in Chapter 20. Figure 28-3 illustrates such a framework, named CyclicExecutive. Among other things, this framework includes a collaboration (CommonEvents) encompassing a set of event classes, along with a mechanism (EventHandler) for processing these events in a cyclic fashion. A client that builds on this framework (such as Pacemaker) could build on the abstractions in CommonEvents via subclassing and could also apply an instance of the EventHandler mechanism. 