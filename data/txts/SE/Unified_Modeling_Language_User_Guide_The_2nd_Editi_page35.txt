Second, there is the separation of interface and implementation. An interface declares a contract, and an implementation represents one concrete realization of that contract, responsible for faithfully carrying out the interface's complete semantics. In the UML, you can model both interfaces and their implementations, as shown in Figure 2-18. Figure 2-18 Interfaces And Implementations  In this figure, there is one component named spellingwizard.dll that implements two interfaces, IUnknown and ISpelling. Almost every building block in the UML has this same kind of interface/ implementation dichotomy. For example, you can have use cases and the collaborations that realize them, as well as operations and the methods that implement them. The UML's extensibility mechanisms are discussed in Chapter 6. Extensibility Mechanisms    The UML provides a standard language for writing software blueprints, but it is not possible for one closed language to ever be sufficient to express all possible nuances of all models across all domains across all time. For this reason, the UML is opened-ended, making it possible for you to extend the language in controlled ways. The UML's extensibility mechanisms include · Stereotypes · Tagged values · Constraints A stereotype extends the vocabulary of the UML, allowing you to create new kinds of building blocks that are derived from existing ones but that are specific to your problem. For example, if you are working in a programming language, such as Java or C++, you will often want to model exceptions. In these languages, exceptions are just classes, although they are treated in very special ways. Typically, you only want to allow them to be thrown and caught, nothing else. You can make exceptions first class citizens in your models#meaning that they are treated like basic building blocks#by marking them with an appropriate stereotype, as for the class Overflow in Figure 2-19. Figure 2-19 Extensibility Mechanisms 