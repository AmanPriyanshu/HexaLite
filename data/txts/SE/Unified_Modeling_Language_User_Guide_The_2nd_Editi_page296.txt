operations in the backplane of your models and use interfaces as handles with which you can find these sets of operations. If you want to construct executable systems against these APIs, you will need to add enough detail so that your development tools can compile against the properties of your interfaces. Along with the signatures of each operation, you'll probably also want to include uses cases that explain how to use each interface. To model an API, · Identify the programmatic seams in your system and model each seam as an interface, collecting the attributes and operations that form this edge. · Expose only those properties of the interface that are important to visualize in the given context; otherwise, hide these properties, keeping them in the interface's specification for reference, as necessary. · Model the realization of each API only insofar as it is important to show the configuration of a specific implementation. Figure 25-7 exposes the APIs of the executable in the previous two figures. You'll see four interfaces that form the API of the executable: IApplication, IModels, IRendering, and IScripts. Figure 25-7 Modeling an API  Modeling Source Code The most common purpose for which you'll use components is to model the physical parts that make up your implementation. This also includes the modeling of all the ancillary parts of your deployed system, including tables, files, documents, and APIs. The second most common purpose for which you'll use components is to model the configuration of all the source code files that your development tools use to create these components. These represent the work product components of your development process. Modeling source code graphically is particularly useful for visualizing the compilation dependencies among your source code files and for managing the splitting and merging of 