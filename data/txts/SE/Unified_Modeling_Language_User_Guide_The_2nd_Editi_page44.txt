Mechanisms Patterns and frameworks are discussed in Chapter 28. The hardest part of mastering a library as rich as Java's is learning how its parts work together. For example, how does HelloWorld's paint operation get invoked? What operations must you use if you want to change the behavior of this applet, such as making it print the string in a different color? To answer these and other questions, you have to have a conceptual model of the way these classes work together dynamically. Processes and threads are discussed in Chapter 22. Studying the Java library reveals that HelloWorld's paint operation is inherited from Component. This still begs the question of how this operation is invoked. The answer is that paint is called as part of running the thread that encloses the applet, as Figure 3-5 illustrates. Figure 3-5 Painting Mechanism  Instances are discussed in Chapter 11. This figure shows the collaboration of several objects, including one instance of the class HelloWorld. The other objects are a part of the Java environment and so, for the most part, live in the background of the applets you create. In the UML, instances are represented just like classes, but with their names underlined to distinguish them. The first three objects in this diagram are anonymous#they have no unique name. The HelloWorld object has a name (target) known by the ComponentPeer object. Sequence diagrams are discussed in Chapter 18. You can model the ordering of events using a sequence diagram, as in Figure 3-5. Here, the sequence begins by running the Thread object, which in turn calls the Toolkit's run operation. The Toolkit object then calls one of its own operations (callbackLoop), which then calls the ComponentPeer's handleExpose operation. The ComponentPeer object then calls its target's paint operation. The ComponentPeer object assumes that its target is a Component, but in this case, the target is actually a child of Component (namely, HelloWorld), and so HelloWorld's paint operation is dispatched polymorphically. Components 