· Lay out its elements to minimize lines that cross. · Organize its elements spatially so that things that are semantically close are laid out physically close. · Use notes and color as visual cues to draw attention to important features of your diagram. · Use stereotyped elements carefully. Choose a small set of common icons for your project or organization and use them consistently. Chapter 30. Deployment Diagrams In this chapter · Modeling an embedded system · Modeling a client/server system · Modeling a fully distributed system · Forward and reverse engineering Component diagrams, the second kind of diagram used in modeling the physical aspects of an object- oriented system, are discussed in Chapter 29. Deployment diagrams are one of the two kinds of diagrams used in modeling the physical aspects of an object-oriented system. A deployment diagram shows the configuration of run time processing nodes and the components that live on them. You use deployment diagrams to model the static deployment view of a system. For the most part, this involves modeling the topology of the hardware on which your system executes. Deployment diagrams are essentially class diagrams that focus on a system's nodes. Deployment diagrams are not only important for visualizing, specifying, and documenting embedded, client/server, and distributed systems, but also for managing executable systems through forward and reverse engineering. Getting Started When you create a software-intensive system, your main focus as a software developer is on architecting and deploying its software. However, as a systems engineer, your main focus is on the system's hardware and software and in managing the trade-offs between the two. Whereas software developers work with somewhat intangible artifacts, such as models and code, system developers work with quite tangible hardware, as well. The UML is primarily focused on facilities for visualizing, specifying, constructing, and documenting software artifacts, but it's also designed to address hardware artifacts. This is not to say that the UML is a general-purpose hardware description language like VHDL. Rather, the UML is designed to model many of the hardware aspects of a system sufficient for a software engineer to specify the platform on which the system's software executes and for a systems engineer to manage the system's hardware/software boundary. In the UML, you use class diagrams and component diagrams to reason about the structure of your software. You use sequence diagrams, collaboration diagrams, statechart diagrams, and activity diagrams to specify the behavior of your software. At the edge of the your system's software and hardware, you use 