concurrent operations must be designed so that they perform correctly in the case of a concurrent sequential or guarded operation on the same object. Active object, processes, and threads are discussed in Chapter 22. The last three properties (sequential, guarded, concurrent) address the concurrency semantics of an operation, properties that are relevant only in the presence of active objects, processes, or threads. Template Classes A template is a parameterized element. In such languages as C++ and Ada, you can write template classes, each of which defines a family of classes (you can also write template functions, each of which defines a family of functions). A template includes slots for classes, objects, and values, and these slots serve as the template's parameters. You can't use a template directly; you have to instantiate it first. Instantiation involves binding these formal template parameters to actual ones. For a template class, the result is a concrete class that can be used just like any ordinary class. The most common use of template classes is to specify containers that can be instantiated for specific elements, making them type-safe. For example, the following C++ code fragment declares a parameterized Map class.                   template<class Item, class Value, int Buckets>            class Map {            public:              virtual Boolean bind(const Item&, const Value&);              virtual Boolean isBound(const Item&) const;              ...            }; You might then instantiate this template to map Customer objects to Order objects.                   m : Map<Customer, Order, 3>; The basic properties of classes are discussed in Chapter 4. You can model template classes in the UML as well. As Figure 9-7 shows, you render a template class just as you do an ordinary class, but with an additional dashed box in the upper-right corner of the class icon, which lists the template parameters. Figure 9-7 Template Classes 