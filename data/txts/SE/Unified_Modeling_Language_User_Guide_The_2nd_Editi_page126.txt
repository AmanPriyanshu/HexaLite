2. incomplete  Specifies that not all children in the generalization have been specified (even if some are elided) and that additional children are permitted The general properties of diagrams are discussed in Chapter 7. Unless otherwise stated, you can assume that any diagram shows only a partial view of an inheritance lattice and so is elided. However, elision is different from the completeness of a model. Specifically, you'll use the complete constraint when you want to show explicitly that you've fully specified a hierarchy in the model (although no one diagram may show that hierarchy); you'll use incomplete to show explicitly that you have not stated the full specification of the hierarchy in the model (although one diagram may show everything in the model). 3. disjoint  Specifies that objects of the parent may have no more than one of the children as a type 4. overlapping  Specifies that objects of the parent may have more than one of the children as a type Types and interfaces are discussed in Chapter 11; interactions are discussed in Chapter 15. These two constraints apply only in the context of multiple inheritance. You'll use disjoint and overlapping when you want to distinguish between static classification (disjoint) and dynamic classification (overlapping). Note In most cases, an object has one type at run time; that's a case of static classification. If an object can change its type during run time, that's a case of dynamic classification. Modeling dynamic classification is complex. But in the UML, you can use a combination of multiple inheritance (to show the potential types of an object) and types and interactions (to show the changing type of an object during run time).  Association The basic properties of associations are discussed in Chapter 5. An association is a structural relationship, specifying that objects of one thing are connected to objects of another. For example, a Library class might have a one-to-many association to a Book class, indicating that each Book instance is owned by one Library instance. Furthermore, given a Book, you can find its owning Library, and given a Library, you can navigate to all its Books. Graphically, an association is rendered as a solid line connecting the same or different classes. You use associations when you want to show structural relationships. There are four basic adornments that apply to an association: a name, the role at each end of the association, the multiplicity at each end of the association, and aggregation. For advanced uses, there are a number of other properties you can use to model subtle details, such as navigation, qualification, and various flavors of aggregation. Navigation   Given a plain, unadorned association between two classes, such as Book and Library, it's possible to navigate from objects of one kind to objects of the other kind. Unless otherwise specified, navigation across an association is bidirectional. However, there are some circumstances in which you'll want to limit navigation to just one direction. For example, as 