These changeability properties apply toattributes, as well, as discussed in Chapter 9; links are discussed in Chapter 15. Next, there are three properties, defined using constraint notation, that relate to the changeability of the instances of an association. Finally, there are three defined constraints that relate to the changeability of the instances of an association. 3. changeable  Links between objects may be added, removed, and changed freely 4. addOnly  New links may be added from an object on the opposite end of the association 5. frozen  A link, once added from an object on the opposite end of the association, may not be modified or deleted Finally, there is one constraint for managing related sets of associations: 6. xor  Specifies that, over a set of associations, exactly one is manfest for each associated object Realization A realizationis a semantic relationship between classifiers in which one classifier specifies a contract that another classifier guarantees to carry out. Graphically, a realization is rendered as a dashed directed line with a large open arrowhead pointing to the classifier that specifies the contract. Realization is sufficiently different from dependency, generalization, and association relationships that it is treated as a separate kind of relationship. Semantically, realization is somewhat of a cross between dependency and generalization, and its notation is a combination of the notation for dependency and generalization. You'll use realization in two circumstances: in the context of interfaces and in the context of collaborations. Interfaces are discussed in Chapter 11; classes are discussed in Chapters 4 and 9; components are discussed in Chapter 25; the five views of an architecture are discussed in Chapter 2. Most of the time, you'll use realization to specify the relationship between an interface and the class or component that provides an operation or service for it. An interface is a collection of operations that are used to specify a service of a class or a component. Therefore, an interface specifies a contract that a class or component must carry out. An interface may be realized by many such classes or components, and a class or component may realize many interfaces. Perhaps the most interesting thing about interfaces is that they let you separate the specification of a contract (the interface itself) from its implementation (by a class or a component). Furthermore, interfaces span the logical and physical parts of a system's architecture. For example, as Figure 10-9 shows, a class (such as AccountBusinessRules in an order entry system) in a system's design view might realize a given interface (such as IRuleAgent). That same interface (IRuleAgent) might also be realized by a component (such as acctrule.dll) in the system's implementation view. Note that you can represent realization in two ways: in the canonical form (using the interface stereotype and the dashed directed line with a large open arrowhead) and in an elided form (using the interface lollipop notation). Figure 10-9 Realization of an Interface 